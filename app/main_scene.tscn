[gd_scene load_steps=7 format=3 uid="uid://ddj7yhyrrg4b8"]

[ext_resource type="PackedScene" uid="uid://cjd68qtn0ujeb" path="res://entities/Units/USA/Infantry/Soldier/soldier.tscn" id="1_o4col"]
[ext_resource type="PackedScene" uid="uid://dpetlsrf5pbpe" path="res://entities/Buildings/GLA/garage/garage_imp.tscn" id="1_sn7h3"]
[ext_resource type="PackedScene" uid="uid://bbsgnge3ole1f" path="res://entities/Maps/ground.tscn" id="2_hvjiq"]
[ext_resource type="PackedScene" uid="uid://hs2mytyqoi4c" path="res://shared/HUD/rts_ui.tscn" id="5_pqs64"]

[sub_resource type="GDScript" id="GDScript_axojy"]
script/source = "extends Camera3D
class_name MainCamera

@export var CAMERA_SPEED_MULTPLIER := 0.05
@export var CAMERA_ROTATION_SPEED := 1

@export var ROTATION_SPEED_MULTIPLIER = 0.005



var selected_nodes: Array[Node3D] = []
const DRAG_THRESHOLD := 5
var ghost_shader = preload(\"res://shaders/ghost_shader.gdshader\")

var dragging := false
var rotating := false
var selecting := false
var selection_start := Vector2()
var selection_rect := Rect2().abs()
var last_mouse_position := Vector2()
var phantom_building: Node3D = null
var rotating_building: bool = false
var can_place: bool = true
var overlapping_bodies_count: int = 0

var selection_overlay: ColorRect

func _init() -> void:
	add_to_group(Constants.cameras)

func _ready():
	# Create selection overlay UI
	var canvas_layer = CanvasLayer.new()
	get_viewport().add_child.call_deferred(canvas_layer)

	var selection_container = Control.new()
	selection_container.name = \"SelectionContainer\"
	selection_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	selection_container.size_flags_vertical = Control.SIZE_EXPAND_FILL
	canvas_layer.add_child(selection_container)

	selection_overlay = ColorRect.new()
	selection_overlay.color = Color(0, 0, 1, 0.3)
	selection_overlay.visible = false
	selection_container.add_child(selection_overlay)

func _process(delta:float) -> void:
	#MouseChanger.mouseChange(self)
	#handleEdgeScrolling(delta)
	#handlecameraZoom(delta)
	HoverHandler.handleHover(self)

	if selecting:
		updateSelectionRectangle()

	# Move phantom building along the ground
	if phantom_building:
		if not rotating_building:
			var mouse_pos = get_viewport().get_mouse_position()
			var ray_origin = project_ray_origin(mouse_pos)
			var ray_dir = project_ray_normal(mouse_pos)
			var ground_plane = Plane(Vector3.UP, 0)
			var intersection = ray_plane_intersection(ray_origin, ray_dir, ground_plane)
			if intersection:
				intersection.y = 0
				phantom_building.global_transform.origin = intersection

func _input(event):
	# Handle mouse button events
	if event is InputEventMouseButton:
		# Phantom building rotation
		if phantom_building and event.button_index == MOUSE_BUTTON_MIDDLE:
			if event.pressed:
				rotating_building = true
				last_mouse_position = event.position
			else:
				rotating_building = false
			return

		# Right mouse button - drag movement
		if event.button_index == MOUSE_BUTTON_RIGHT:
			if phantom_building:
				cancel_building_placement()
				return
			dragging = event.pressed
			last_mouse_position = event.position
			return

		# Middle mouse button - camera rotation
		if event.button_index == MOUSE_BUTTON_MIDDLE:
			rotating = event.pressed
			last_mouse_position = event.position
			return

		# Left mouse button - selection
		#if event.button_index == MOUSE_BUTTON_LEFT:
			#if is_mouse_over_ui():
				#return # Block input if mouse is over UI

			if event.pressed:
				handle_left_mouse_press(event)
			else:
				handle_left_mouse_release(event)

	# Handle mouse movement (drag and rotate)
	elif event is InputEventMouseMotion:
		handle_mouse_motion(event)

# Helper functions

func handle_left_mouse_press(event):
	if phantom_building:
		finish_building_placement()
		return

	# Shift + click selects multiple units
	if Input.is_action_pressed(\"MULTI_SELECT\"):
		handle_multi_select(event)
	elif event.double_click:
		handle_double_click(event)
	else:
		# Start selection box
		start_selection_box(event)

func handle_left_mouse_release(event):
	if selecting:
		selecting = false
		selection_overlay.visible = false
		if event.position.distance_to(selection_start) > DRAG_THRESHOLD:
			SelectionHandler.handleSelectionBySelectionRect(self)
		else:
			handle_single_selection(event)
		# Update UI with selected nodes
		update_ui_selection()

func handle_mouse_motion(event):
	if phantom_building and rotating_building:
		#if is_mouse_over_ui():
			#return # Block input if over UI
		var delta_angle = event.position.x - last_mouse_position.x
		phantom_building.rotate_y(-delta_angle * ROTATION_SPEED_MULTIPLIER)
		last_mouse_position = event.position

	if dragging:
		var delta_move = event.position - last_mouse_position
		var move_x = transform.basis.x * delta_move.x * CAMERA_SPEED_MULTPLIER
		var move_z = transform.basis.z * delta_move.y * CAMERA_SPEED_MULTPLIER
		move_x.y = 0
		move_z.y = 0
		position += move_x + move_z
		last_mouse_position = event.position
	elif rotating:
		var delta_rotate = (event.position - last_mouse_position) * ROTATION_SPEED_MULTIPLIER
		rotate_y(-delta_rotate.x)
		last_mouse_position = event.position

# Selection-related functions

func handle_multi_select(event):
	var result = RaycastHandler.getRaycastResult(self)
	if result:
		selected_nodes = SelectionHandler.handleMultipleSelectionByShift(selected_nodes, result)

func handle_double_click(event):
	var result = RaycastHandler.getRaycastResult(self)
	if result:
		selected_nodes = SelectionHandler.handleMultipleSelectionByDoubleClick(selected_nodes, result, self)

func start_selection_box(event):
	selecting = true
	selection_start = event.position
	selection_overlay.position = selection_start
	selection_overlay.size = Vector2.ZERO
	selection_overlay.visible = true

func handle_single_selection(event):
	var result = RaycastHandler.getRaycastResult(self)
	if result:
		selected_nodes = SelectionHandler.handleSingleSelection(selected_nodes, result)

func update_ui_selection():
	var ui = get_tree().get_root().get_node(\"MainScene/RTS_UI\")
	if ui:
		ui.update_selected_objects(selected_nodes)

func updateSelectionRectangle():
	var current_mouse_pos = get_viewport().get_mouse_position()
	selection_rect = Rect2(selection_start, current_mouse_pos - selection_start).abs()
	selection_overlay.position = selection_rect.position
	selection_overlay.size = selection_rect.size

#func handlecameraZoom(delta:float)-> void:
	#if position.y >= 10 and Input.is_action_just_pressed(\"ZOOM_IN\"):
		## -transform.basis.z дает локальный вектор \"вперед\" камеры
		#var zoom_offset: Vector3 = -transform.basis.z * ZOOM_SPEED_MULTPLIER * delta
		#print(\"Zoom offset: \", zoom_offset)
		#position += zoom_offset
	#elif Input.is_action_just_pressed(\"ZOOM_OUT\") and position.y < 40:
		#var zoom_offset: Vector3 = -transform.basis.z * -1 * ZOOM_SPEED_MULTPLIER * delta
		#print(\"Zoom offset: \", zoom_offset)
		#position += zoom_offset

#func handleEdgeScrolling(delta: float) -> void:
	#if is_mouse_over_ui():
		#return  # Блокировать ввод, если курсор над UI
#
	#var viewport_size = get_viewport().size
	#var mouse_pos = get_viewport().get_mouse_position()
#
	## Проверяем, что курсор в пределах окна
	#if mouse_pos.x < 0 or mouse_pos.x > viewport_size.x or mouse_pos.y < 0 or mouse_pos.y > viewport_size.y:
		#return
#
	#var move_dir = Vector3.ZERO
#
	## Функция для расчёта множителя скорости
	#var calculate_speed_multiplier = func(pos: float, margin: float, max_size: float) -> float:
		#if pos <= margin:
			#return -(1.0 - (pos / margin))  # Левый/верхний край (отрицательное значение)
		#elif pos >= max_size - margin:
			#return 1.0 - ((max_size - pos) / margin)  # Правый/нижний край (положительное значение)
		#return 0.0
#
	## Рассчитываем множитель скорости
	#var speed_x = calculate_speed_multiplier.call(mouse_pos.x, EDGE_MARGIN, viewport_size.x)
	#var speed_z = calculate_speed_multiplier.call(mouse_pos.y, EDGE_MARGIN, viewport_size.y)
#
	## Корректное направление движения
	#move_dir += transform.basis.x * speed_x
	#move_dir += transform.basis.z * speed_z
#
	## Убираем перемещение по Y
	#move_dir.y = 0
#
	## Применяем множитель скорости (от 0 до 100%)
	#if move_dir.length() > 0:
		#position += move_dir.normalized() * EDGE_SCROLL_SPEED * abs(speed_x + speed_z) * delta

func start_building_placement(building_name: String) -> void:
	# If there is an old phantom object, delete and restore the materials
	if phantom_building:
		fix_building_transparency(phantom_building)
		phantom_building.queue_free()
		phantom_building = null
	
	# Load new phantom object
	var path = \"res://entities/Buildings/\" + building_name + \".tscn\"
	if ResourceLoader.exists(path):
		var building_scene = load(path).instantiate()
		
		duplicate_meshes(building_scene)
	
		phantom_building = building_scene
		phantom_building.rotation = Vector3(phantom_building.rotation.x, 0.0, phantom_building.rotation.z)
		phantom_building.scale = Vector3(0.5, 0.5, 0.5)
	
		apply_ghost_shader(phantom_building)
		disable_colliders(phantom_building)
		setup_phantom_area(phantom_building)
		get_tree().get_current_scene().add_child(phantom_building)
	else:
		print(\"Error: Scene not found at path:\", path)

# Duplicate the mesh so that its materials are not shared
#func duplicate_meshes(node: Node) -> void:
	#if node is MeshInstance3D and node.mesh:
		#node.mesh = node.mesh.duplicate()
	#for child in node.get_children():
		#duplicate_meshes(child)

#func disable_colliders(node: Node) -> void:
	#if node is CollisionShape3D:
		#node.disabled = true
	#for child in node.get_children():
		#disable_colliders(child)

#func enable_colliders(node: Node) -> void:
	#if node is CollisionShape3D:
		#node.disabled = false
	#for child in node.get_children():
		#enable_colliders(child)

#func find_first_collision_shape(node: Node) -> CollisionShape3D:
	#if node is CollisionShape3D:
		#return node
	#for child in node.get_children():
		#var collider = find_first_collision_shape(child)
		#if collider:
			#return collider
	#return null

# Add Area3D for intersection detection
#func setup_phantom_area(node: Node) -> void:
	#var area = Area3D.new()
	#var new_collision_shape = CollisionShape3D.new()
	#
	#var original_collider = find_first_collision_shape(node)
	#new_collision_shape.shape = original_collider.shape.duplicate()
	#new_collision_shape.position = original_collider.position
	#new_collision_shape.rotation = original_collider.rotation
	#
	#area.add_child(new_collision_shape)
	#area.monitoring = true
	#area.monitorable = true
	#area.collision_layer = 2
	#area.collision_mask = 2
	#node.add_child(area)
	#area.connect(\"body_entered\", Callable(self,\"_on_phantom_area_body_entered\"))
	#area.connect(\"body_exited\", Callable(self, \"_on_phantom_area_body_exited\"))

func _on_phantom_area_body_entered(body: Node) -> void:
	overlapping_bodies_count += 1
	set_phantom_collision_state(true)

func _on_phantom_area_body_exited(body: Node) -> void:
	overlapping_bodies_count -= 1
	if overlapping_bodies_count <= 0:
		overlapping_bodies_count = 0
		set_phantom_collision_state(false)

func set_phantom_collision_state(is_colliding: bool) -> void:
	can_place = not is_colliding
	update_phantom_material_color(phantom_building, is_colliding)

func update_phantom_material_color(node: Node, is_colliding: bool) -> void:
	if node is MeshInstance3D and node.mesh:
		for i in range(node.mesh.get_surface_count()):
			var mat = node.mesh.surface_get_material(i)
			if mat and (mat is ShaderMaterial):
				if is_colliding:
					mat.set_shader_parameter(\"albedo_color\", Color(1, 0, 0))
				else:
					var orig_mat = mat.get_shader_parameter(\"original_material\")
					if orig_mat and orig_mat is StandardMaterial3D:
						mat.set_shader_parameter(\"albedo_color\", orig_mat.albedo_color)
	if node:
		for child in node.get_children():
				update_phantom_material_color(child, is_colliding)

#func apply_ghost_shader(node: Node) -> void:
	#if node is MeshInstance3D and node.mesh:
		#var surface_count = node.mesh.get_surface_count()
		#for i in range(surface_count):
			#var orig_mat = node.mesh.surface_get_material(i)
			#if orig_mat and not (orig_mat is ShaderMaterial):
				#var ghost_material := ShaderMaterial.new()
				#ghost_material.shader = ghost_shader
				#ghost_material.set_shader_parameter(\"ghost_alpha\", 0.5)
				#ghost_material.set_shader_parameter(\"original_material\", orig_mat)
#
				#if orig_mat is StandardMaterial3D:
					#ghost_material.set_shader_parameter(\"albedo_texture\", orig_mat.albedo_texture)
					#ghost_material.set_shader_parameter(\"albedo_color\", orig_mat.albedo_color)
#
				#node.mesh.surface_set_material(i, ghost_material)
#
	#for child in node.get_children():
		#apply_ghost_shader(child)

#func fix_building_transparency(node: Node) -> void:
	#if node is MeshInstance3D and node.mesh:
		#var surface_count = node.mesh.get_surface_count()
		#for i in range(surface_count):
			#var orig_mat = node.mesh.surface_get_material(i)
			#if orig_mat and orig_mat is ShaderMaterial:
				#var prev_mat = orig_mat.get_shader_parameter(\"original_material\")
				#if prev_mat:
					#node.mesh.surface_set_material(i, prev_mat)
#
	#for child in node.get_children():
		#fix_building_transparency(child)
#
#func cancel_building_placement() -> void:
	#if phantom_building:
		#fix_building_transparency(phantom_building)
		#phantom_building.queue_free()
		#phantom_building = null
#
#func finish_building_placement() -> void:
	#if phantom_building and can_place:
		#for child in phantom_building.get_children():
			#if child is Area3D:
				#child.queue_free()
		#enable_colliders(phantom_building)
		#fix_building_transparency(phantom_building)
		#phantom_building = null

func ray_plane_intersection(origin: Vector3, dir: Vector3, plane: Plane) -> Vector3:
	var denom = plane.normal.dot(dir)
	if abs(denom) < 0.001:
		return Vector3.ZERO
	var t = -(plane.normal.dot(origin) + plane.d) / denom
	if t < 0:
		return Vector3.ZERO
	return origin + dir * t

#func is_mouse_over_ui() -> bool:
	#var ui = get_tree().get_root().get_node(\"MainScene/RTS_UI\")
	#if not ui:
		#return false
	#
	#var mouse_pos = get_viewport().get_mouse_position()
	#
	#for node in ui.find_children(\"\", \"Control\", true):
		#if node.visible and node.get_global_rect().has_point(mouse_pos):
			#return true
	#
	#return false
"

[sub_resource type="NavigationMesh" id="NavigationMesh_beipy"]
vertices = PackedVector3Array(-8.75, 0.5, -15.75, -1.5, 0.5, -15.75, -1.25, 0.5, -19.5, -19.5, 0.5, -19.5, -19.5, 0.5, -11.75, -9, 0.5, -11.75, 0.25, 0.5, -15.5, 15.5, 0.5, -3.25, 15.75, 0.5, 2.25, 19.5, 0.5, 1.75, 19.5, 0.5, -19.5, 0.25, 0.5, -9.75, 6.75, 0.5, -3.25, -6.25, 6, -15.5, -6.25, 6, -10, -2.5, 6, -10, -2.5, 6, -15.5, -8, 3.75, -10.25, -6.5, 3.75, -10.25, -6.25, 3.5, -11.25, -5.25, 3.5, -11.25, -5.5, 3.5, -14.25, -8, 3.5, -14.75, -2.5, 3.5, -11.25, -2.25, 3.75, -10.25, -0.75, 3.75, -10.25, -3.25, 3.5, -14.25, -3.25, 3.5, -11.25, -0.75, 3.5, -14.75, -7.5, 0.5, -14.5, -7.5, 0.5, -10.75, -1.25, 0.5, -10.75, -1.25, 0.5, -14.5, -4.5, 4.25, -12.25, -4, 4.25, -12.25, -4, 4.25, -13.25, -4.5, 4.25, -13.5, -9, 0.5, -9.75, -19.5, 0.5, 6, -8.25, 0.5, 6.25, -7.5, 0.5, 6.25, -7.5, 0.5, -9.25, -5, 3.75, -10.25, -3.5, 3.75, -10.25, -3.25, 3.5, -11, 0.25, 0.5, 6.25, 0.5, 0.5, 6.75, 6.5, 0.5, 2.75, 9, 6, -3, 9, 6, 2.5, 13, 6, 2.5, 13, 6, -3, 9, 3.5, -1.75, 9, 3.5, -2.25, 7.25, 3.75, -2.25, 7.25, 3.75, 2.25, 9, 3.5, 2.25, 9, 3.5, 1.5, 9.75, 3.5, -1.5, 10, 3.5, 1.25, 14.75, 3.5, -2.25, 13.25, 3.5, -2.25, 13, 3.5, -1.5, 13, 3.5, 1.25, 13.25, 3.5, 2.25, 14.75, 3.5, 2.25, 12.25, 3.5, -1.5, 12, 3.5, 1, 7.75, 0.5, -1.75, 7.75, 0.5, 1.75, 14.25, 0.5, 1.75, 14.25, 0.5, -1.75, 10.75, 4.25, -1, 10.75, 4.25, 0.25, 11.25, 4.25, 0.25, 11.25, 4.25, -1, 10.25, 3.5, 2.25, 11.75, 3.5, 2.25, 12, 3.5, 1.5, 15.5, 0.5, 3.25, 19.5, 0.5, 19.5, 6.75, 0.5, 3.25, 0.5, 0.5, 12.25, -1.75, 0.5, 12.5, -1.75, 0.5, 19.5, -6.5, 0.5, 19.5, -6.25, 0.5, 12.75, -8.75, 0.5, 12.25, -8.75, 0.5, 6.5, -19.5, 0.5, 19.5, -6, 6, 6.5, -6, 6, 12, -2, 6, 12, -2, 6, 6.5, -0.25, 3.75, 7, -1.75, 3.75, 7, -2, 3.5, 7.75, -2, 3.5, 10.75, -1.75, 3.75, 11.75, -0.25, 3.75, 11.75, -6, 3.5, 7.75, -6.25, 3.75, 7, -7.75, 3.75, 7, -7.75, 3.75, 11.75, -6.25, 3.75, 11.75, -6, 3.5, 10.75, -5, 3.5, 10.5, -5.25, 3.5, 7.75, -5, 3.5, 10.75, -4.75, 3.75, 11.75, -3.25, 3.75, 11.75, -3, 3.5, 10.75, -3, 3.5, 10.5, -2.75, 3.5, 7.75, -7.25, 0.5, 7.5, -7.25, 0.5, 11.25, -0.75, 0.5, 11.25, -0.75, 0.5, 7.5, -4.25, 4.25, 8.5, -4.25, 4.25, 9.5, -3.75, 4.25, 9.5, -3.75, 4.25, 8.5)
polygons = [PackedInt32Array(1, 0, 2), PackedInt32Array(2, 0, 3), PackedInt32Array(5, 4, 0), PackedInt32Array(0, 4, 3), PackedInt32Array(6, 1, 2), PackedInt32Array(8, 7, 9), PackedInt32Array(9, 7, 10), PackedInt32Array(12, 11, 6), PackedInt32Array(6, 2, 12), PackedInt32Array(12, 2, 7), PackedInt32Array(7, 2, 10), PackedInt32Array(16, 15, 13), PackedInt32Array(13, 15, 14), PackedInt32Array(19, 18, 17), PackedInt32Array(21, 20, 19), PackedInt32Array(21, 19, 22), PackedInt32Array(22, 19, 17), PackedInt32Array(25, 24, 23), PackedInt32Array(23, 27, 26), PackedInt32Array(26, 28, 23), PackedInt32Array(23, 28, 25), PackedInt32Array(32, 31, 29), PackedInt32Array(29, 31, 30), PackedInt32Array(34, 33, 35), PackedInt32Array(35, 33, 36), PackedInt32Array(4, 5, 37), PackedInt32Array(39, 38, 40), PackedInt32Array(40, 38, 41), PackedInt32Array(41, 38, 37), PackedInt32Array(37, 38, 4), PackedInt32Array(43, 42, 44), PackedInt32Array(44, 42, 20), PackedInt32Array(47, 46, 45), PackedInt32Array(47, 45, 12), PackedInt32Array(12, 45, 40), PackedInt32Array(12, 40, 11), PackedInt32Array(11, 40, 41), PackedInt32Array(51, 50, 48), PackedInt32Array(48, 50, 49), PackedInt32Array(54, 53, 52), PackedInt32Array(57, 56, 55), PackedInt32Array(52, 58, 54), PackedInt32Array(54, 58, 57), PackedInt32Array(54, 57, 55), PackedInt32Array(58, 59, 57), PackedInt32Array(61, 60, 62), PackedInt32Array(62, 60, 63), PackedInt32Array(63, 60, 64), PackedInt32Array(64, 60, 65), PackedInt32Array(66, 62, 67), PackedInt32Array(67, 62, 63), PackedInt32Array(71, 70, 68), PackedInt32Array(68, 70, 69), PackedInt32Array(75, 74, 72), PackedInt32Array(72, 74, 73), PackedInt32Array(77, 76, 78), PackedInt32Array(78, 76, 59), PackedInt32Array(8, 9, 79), PackedInt32Array(79, 9, 80), PackedInt32Array(47, 81, 46), PackedInt32Array(46, 81, 82), PackedInt32Array(84, 83, 82), PackedInt32Array(82, 81, 84), PackedInt32Array(84, 81, 79), PackedInt32Array(84, 79, 80), PackedInt32Array(85, 87, 86), PackedInt32Array(38, 39, 88), PackedInt32Array(38, 88, 87), PackedInt32Array(85, 89, 87), PackedInt32Array(87, 89, 38), PackedInt32Array(93, 92, 90), PackedInt32Array(90, 92, 91), PackedInt32Array(95, 94, 96), PackedInt32Array(96, 94, 97), PackedInt32Array(97, 94, 98), PackedInt32Array(98, 94, 99), PackedInt32Array(101, 100, 102), PackedInt32Array(102, 100, 105), PackedInt32Array(102, 105, 104), PackedInt32Array(102, 104, 103), PackedInt32Array(108, 105, 106), PackedInt32Array(106, 105, 107), PackedInt32Array(107, 105, 100), PackedInt32Array(108, 106, 109), PackedInt32Array(109, 106, 110), PackedInt32Array(110, 106, 111), PackedInt32Array(111, 106, 112), PackedInt32Array(111, 112, 97), PackedInt32Array(97, 112, 113), PackedInt32Array(97, 113, 96), PackedInt32Array(117, 116, 114), PackedInt32Array(114, 116, 115), PackedInt32Array(121, 120, 118), PackedInt32Array(118, 120, 119), PackedInt32Array(85, 86, 84), PackedInt32Array(84, 86, 83)]

[node name="MainScene" type="Node3D"]

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(-1, 7.71897e-08, -4.10425e-08, -1.95898e-09, 0.449569, 0.893246, 8.74008e-08, 0.893246, -0.449569, -1.48664, 12.5988, -22.3207)
script = SubResource("GDScript_axojy")
CAMERA_SPEED_MULTPLIER = null
CAMERA_ROTATION_SPEED = null
ROTATION_SPEED_MULTIPLIER = null

[node name="RayCast3D" type="RayCast3D" parent="Camera3D"]

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, -0.873772, 0.486335, 0, -0.486335, -0.873772, 0, 9.89356, -15.9748)

[node name="NavigationRegion3D" type="NavigationRegion3D" parent="."]
navigation_mesh = SubResource("NavigationMesh_beipy")

[node name="Ground" parent="NavigationRegion3D" instance=ExtResource("2_hvjiq")]

[node name="GarageImp" parent="NavigationRegion3D" instance=ExtResource("1_sn7h3")]
transform = Transform3D(0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5, -1.771, 0, 9.498)

[node name="GarageImp2" parent="NavigationRegion3D" instance=ExtResource("1_sn7h3")]
transform = Transform3D(0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 13.3159, 0, 0.100148)

[node name="GarageImp3" parent="NavigationRegion3D" instance=ExtResource("1_sn7h3")]
transform = Transform3D(0.5, 0, 0, 0, 0.5, 0, 0, 0, 0.5, -2.06647, 0, -12.4719)

[node name="Soldier" parent="." instance=ExtResource("1_o4col")]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 9.87615, 0, -9.82027)

[node name="RTS_UI" parent="." instance=ExtResource("5_pqs64")]
